name: CD - D√©ploiement

on:
  push:
    branches:
      - main
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environnement de d√©ploiement'
        required: true
        type: choice
        options:
          - staging
          - production

env:
  NODE_VERSION: '22'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository | lower }}

jobs:
  # Build et push de l'image Docker
  build-and-push:
    name: Build et Push Image Docker
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout du code
        uses: actions/checkout@v5

      - name: Configuration de Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Connexion au registre GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extraction des m√©tadonn√©es Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
            images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
            tags: |
              type=ref,event=branch
              type=ref,event=pr
              type=semver,pattern={{version}}
              type=semver,pattern={{major}}.{{minor}}
              type=semver,pattern={{major}}
              type=sha,prefix={{branch}}-
              type=raw,value=latest,enable={{is_default_branch}}

      - name: Build et Push de l'image Docker
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.meta.outputs.version }}

      - name: Scan de s√©curit√© de l'image Docker
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload des r√©sultats du scan
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # D√©ploiement en staging
  deploy-staging:
    name: D√©ployer en Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/develop' || github.event.inputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.devfest-studio.example.com

    steps:
      - name: Checkout du code
        uses: actions/checkout@v5

      - name: Configuration kubectl
        uses: azure/setup-kubectl@v4
        if: false  # Activez si vous utilisez Kubernetes

      - name: D√©ploiement sur le serveur staging
        run: |
          echo "üöÄ D√©ploiement en staging..."
          # Ajoutez ici vos commandes de d√©ploiement
          # Exemple avec SSH:
          # ssh user@staging-server "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:develop"
          # ssh user@staging-server "docker-compose up -d"
          echo "‚úÖ D√©ploiement staging termin√©"

      - name: Test de sant√© staging
        run: |
          echo "üè• V√©rification de la sant√© de l'application..."
          # curl -f https://staging.devfest-studio.example.com/api/v1/health

  # D√©ploiement en production
  deploy-production:
    name: D√©ployer en Production
    runs-on: ubuntu-latest
    needs: build-and-push
    if: startsWith(github.ref, 'refs/tags/v') || github.event.inputs.environment == 'production'
    environment:
      name: production
      url: https://api.devfest-studio.example.com

    steps:
      - name: Checkout du code
        uses: actions/checkout@v5

      - name: Confirmation du d√©ploiement
        run: |
          echo "‚ö†Ô∏è D√©ploiement en PRODUCTION"
          echo "Version: ${{ github.ref_name }}"
          echo "SHA: ${{ github.sha }}"

      - name: D√©ploiement sur le serveur production
        run: |
          echo "üöÄ D√©ploiement en production..."
          # Ajoutez ici vos commandes de d√©ploiement production
          # Exemple avec SSH:
          # ssh user@prod-server "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          # ssh user@prod-server "docker-compose up -d --no-deps api"
          echo "‚úÖ D√©ploiement production termin√©"

      - name: Test de sant√© production
        run: |
          echo "üè• V√©rification de la sant√© de l'application..."
          # curl -f https://api.devfest-studio.example.com/api/v1/health

      - name: Cr√©ation d'une release GitHub
        uses: softprops/action-gh-release@v2
        if: startsWith(github.ref, 'refs/tags/')
        with:
          generate_release_notes: true
          files: |
            dist/**/*

  # Rollback en cas d'√©chec
  rollback:
    name: Rollback
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: failure()

    steps:
      - name: Rollback automatique
        run: |
          echo "‚ö†Ô∏è √âchec d√©tect√© - Rollback en cours..."
          # Ajoutez ici la logique de rollback
          # Exemple: d√©ployer la version pr√©c√©dente
          echo "‚úÖ Rollback termin√©"
